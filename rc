
" Fix runtimepath. {{{

" Make sure $USERVIM is present first in runtimepath, and $USERVIM/after last.
" Also remove dupplicate and directories that don't exist.

let uvim = simplify($USERVIM)
let uvim_after = simplify($USERVIM.'/after')

let rl = split(&runtimepath, ',')
let newrl = []

for path in rl
  let path = simplify(path)
  if isdirectory(path) && -1 == index(newrl, path)
    call add(newrl, path)
  endif
endfor

if 0 != len(newrl)
  if uvim != newrl[0]
    call insert(newrl, uvim, 0)
  endif
  if uvim_after != newrl[-1]
    call add(newrl, uvim_after)
  endif
endif

let &runtimepath = join(newrl, ',')

" }}}

" Load user config (username, email, ...).
let user = $USERVIM."/user"
if filereadable(user)
  execute "source ".user
endif

language C

" Not VI compatible.
set nocompatible

" No wrapping, but use ^ and $ for incomplete lines.
set nowrap
set lcs=precedes:^,extends:$

" Show line numbers.
set number
set numberwidth=5

" To keep hidden buffers
" (so we can change buffer without
" the need to write changes...).
set hidden

" Use status line to display possible completions.
set wildmenu
set wildmode=list:longest,full

" No search highlight, incremental search.
set nohlsearch
set incsearch

" Do not redraw while running macros (much faster).
set lazyredraw

" Always show tabline.
set showtabline=2

" Save info file in the user VIM directory.
let &viminfo = "!,'20,\"50,n".$USERVIM."/info"

" Change the select/visual mode behavior.
behave xterm
set selectmode=key
set keymodel=startsel

" Activate use of filetype, indent, and plugin.
filetype on
filetype indent on
filetype plugin on

" Syntax highlighting.
syntax on

" More info during some commands (like visual selection).
set showcmd

" Win32 specific config. {{{

if has('win32')

  if !executable('sh') && !empty($CYGPATH)
    let $PATH = $CYGPATH.'/bin;'.$PATH
  end

  " Look for a real shell.
  if executable('sh')
    set shell=sh
    set shellcmdflag=-c
    set shellpipe=2&>1\|\ tee
    set shellquote=
    set shellredir=>%s\ 2>&1
    set shellslash
    set shelltemp
    set shellxquote=\"
  endif


endif

" }}}

" Status line. {{{

" Show statusline even if only one window is visible.
set laststatus=2

" Better status line.
set statusline=
      \%<%f\ %h%y\ %{&ff}\ %{&fenc}   " file name/type/format/encoding
      \%(\ %{&diff?'[d]':''}%)\       " diff mode
      \%(\ %m%)%(\ %r%)%=%-24.        " buffer modified/readonly
      \(\ %l,%c%V\ [%b,0x%B]\ %)\ %P  " position

" }}}

" Need -w to correctly parse compilation errors when switching directories.
set makeprg=make\ -w

" Put swap files in $USERVIM/swap or ~/tmp
" (fallback to current dir if not possible).
let swap = $USERVIM."/swap"
if !isdirectory(swap)
  call mkdir(swap)
endif
let &directory = swap.'//,~/tmp//,.'

" Terminal only settings. {{{

if !has("gui_running")

  " Load specific term keys setting.
  " Needed for some mappings to work properly.
  let keys = $USERVIM."/keys/".$TERM
  if filereadable(keys)
    execute "source " . keys
  endif

  " Fast escape key.
  set timeout timeoutlen=3000 ttimeoutlen=100

  " Colorscheme.
  let g:moria_style = 'black'
  set background=dark
  colorscheme moria_256

  " Enable mouse support for all modes but command line.
  set mouse=nvi

endif

" }}}

" Backspace/Delete behaviour. {{{

" Allow backspacing over everything in insert mode.
set backspace=2

" Backward delete word and delete word in insert and command mode.
imap <C-BS> <C-w>
cmap <C-BS> <C-w>

" }}}

" Cscope support. {{{

if has("cscope")

  set cscopequickfix=s-,g-,d-,c-,t-,e-,f-,i-
  set cspc=3
  set csverb

  " Check for either stock cscope executable or for the multi-lingual cscope
  " version (which is the one available in Cygwin).
  if !executable(&cscopeprg)
    if executable('cscope')
      set cscopeprg=cscope
    elseif executable('mlcscope')
      set cscopeprg=mlcscope
    endif
  endif

  " Add any database in current directory.
  if filereadable("cscope.out")
    silent cs add cscope.out
    " Add database pointed to by environment.
  elseif strlen($CSCOPE_DB)
    silent cs add $CSCOPE_DB
  endif

  " Uses cstag (and so cscope if available...).
  set cst
  " Search the tags database before the scope database...
  set csto=1

  " Mappings.
  nmap <unique> <silent> <Leader>tg <C-]>
  nmap <unique> <silent> <Leader>ts :exe 'cscope find s <cword>'<CR>
  nmap <unique> <silent> <Leader>td :exe 'cscope find d <cword>'<CR>
  nmap <unique> <silent> <Leader>tc :exe 'cscope find c <cword>'<CR>
  nmap <unique> <silent> <Leader>ta :exe 'cscope find t <cword>'<CR>
  nmap <unique> <silent> <Leader>tf :exe 'cscope find f <cfile>'<CR>
  nmap <unique> <silent> <Leader>ti :exe 'cscope find i %:t'<CR>
  nmap <unique> <silent> <Leader>tu :
        \ exe 'silent! cscope k 0' <Bar>
        \ exe '!'.&cscopeprg.' -q -R -b -s .' <Bar>
        \ exe 'silent cscope add cscope.out' <CR>

endif

" }}}

" Ctags support. {{{

" To update a ctags database.
let g:ctags_flags = '--c-kinds=+cdefgmnpstuvx --fields=+S'
nmap <unique> <Leader>tU :
      \ exe 'silent! !ctags '.g:ctags_flags.' -R -o tags .' <CR>

" Ctags list plugin config.
let Tlist_Enable_Fold_Column = 0
let Tlist_Sort_Type = "name"
let Tlist_Show_One_File = 1
let Tlist_Show_Menu = 0
nmap <silent> <unique> <Leader>tl :exe "Tlist"\|wincmd p<CR>

" }}}

" Diffing. {{{

" To toggle whitespace ignore for diffs.
map <unique> <silent> <Leader>dg :diffget<CR>
map <unique> <silent> <Leader>dp :diffput<CR>
map <unique> <silent> <Leader>du :diffupdate<CR>
map <unique> <silent> <Leader>d<space> :
      \ if &diffopt =~ ',\?iwhite\>' <Bar>
      \   set diffopt-=iwhite <Bar>
      \ else <Bar>
      \   set diffopt+=iwhite <Bar>
      \ endif <CR>
map <unique> <silent> <Leader>dd :
      \ if &diff <Bar>
      \   set nodiff noscrollbind <Bar>
      \ else <Bar>
      \   diffthis <Bar>
      \ endif <CR>

" Mappings for blockdiff plugin.
vmap <unique> <silent> <Leader>d1 :call BlockDiff_GetBlock1()<CR>
vmap <unique> <silent> <Leader>d2 :call BlockDiff_GetBlock2()<CR>

" DirDiff options.
let g:DirDiffExcludes = 'CVS,.svn,.bzr,cscope*out,tags'
let g:DirDiffAddArgs = '--strip-trailing-cr'

" }}}

" ManPageView plugin. {{{

let g:manpageview_multimanpage = 0

" }}}

" Improved completion. {{{

set complete=.,t,i,k
set completeopt-=preview

function! CleverTab()
  set completeopt-=longest
  if pumvisible()
    return "\<C-P>"
  endif
  let text = IMAP_LookupCharacter("\t")
  if text != "\t"
    return text
  end
  let to_pos = strpart(getline('.'), 0, col('.') - 1 )
  let from_pos = strpart(getline('.'), col('.') - 2, col('$'))
  if has('ruby')
    if to_pos =~ '<%=\f*$'
      set completefunc=yasnippets#CompleteSkeleton
      set completeopt+=longest
      return "\<C-X>\<C-U>"
    end
  end
  if to_pos =~ '<%=\w\+>'
    return IMAP_LookupCharacter('>')
  end
  if to_pos =~ '\w\(\.\|->\)$'
    return "\<C-X>\<C-O>"
  endif
  let fn = matchlist(to_pos, '\<\(\w\+\)($')
  if !empty(fn)
    return FunctionComplete(fn[1])
  endif
  if to_pos =~ '^\s*#\s*include'
    if to_pos =~ '^\s*#\s*include\s*$'
      return " \"\<C-X>\<C-F>\"\<Left>"
    endif
    return "\<C-X>\<C-F>"
  elseif from_pos =~ '^\k'
    return "\<C-P>"
  endif
  return "\<Tab>"
endfunction
inoremap <silent> <Tab> <C-R>=CleverTab()<CR>

function! SCleverTab()
  let to_pos = strpart(getline('.'), 0, col('.') - 1 )
  let from_pos = strpart(getline('.'), col('.') - 2, col('$'))
  if from_pos =~ '^\k'
    return "\<C-N>"
  endif
  return "\<Tab>"
endfunction
inoremap <silent> <S-Tab> <C-R>=SCleverTab()<CR>

inoremap <C-]> <C-x><C-]>
inoremap <C-f> <C-x><C-f>
inoremap <C-d> <C-x><C-d>
inoremap <C-l> <C-x><C-l>
inoremap <C-k> <C-x><C-k>

" }}}

" Plugins. {{{

" Mappings for mark plugin.
nmap <unique> <silent> <leader>mm <Plug>MarkSet
vmap <unique> <silent> <leader>mm <Plug>MarkSet
nmap <unique> <silent> <leader>mr <Plug>MarkRegex
vmap <unique> <silent> <leader>mr <Plug>MarkRegex
nmap <unique> <silent> <leader>mn <Plug>MarkClear

" Have vimball put file in $USERVIM.
let g:vimball_home = $USERVIM

" Configure tSkeleton plugin.
let g:tskelUserName = username
let g:tskelUserEmail = useremail

" Configure yasnippets.
if has('ruby')
  ruby $AUTHOR = VIM::evaluate('g:tskelUserName')
  ruby $EMAIL = VIM::evaluate('g:tskelUserEmail')
else
  let loaded_yasnippets = 1
end

" Configure NERD_commenter plugin.
let g:NERDShutUp = 1
let g:NERDSpaceDelims = 1

" Do not switch tab/window when selecting an already opened buffer with
" bufexplorer.
let g:bufExplorerFindActive = 0

" Don't load rb_align plugin if ruby feature is not available.
if !has('ruby')
  let loaded_rb_align = 1
end

" }}}

" Buffer navigation. {{{

nmap <silent> <M-Right> :bn<CR>
nmap <silent> <M-Left> :bp<CR>
nmap <silent> <M-1> :brewind<CR>
nmap <silent> <M-2> :brewind <bar> bn<CR>
nmap <silent> <M-3> :brewind <bar> bn 2<CR>
nmap <silent> <M-4> :brewind <bar> bn 3<CR>
nmap <silent> <M-5> :brewind <bar> bn 4<CR>
nmap <silent> <M-6> :brewind <bar> bn 5<CR>
nmap <silent> <M-7> :brewind <bar> bn 6<CR>
nmap <silent> <M-8> :brewind <bar> bn 7<CR>
nmap <silent> <M-9> :brewind <bar> bn 8<CR>
nmap <silent> <M-0> :blast<CR>

" }}}

" For iterating on errors.
nmap <silent> <M-up> :cp<CR>
nmap <silent> <M-down> :cn<CR>

" Buffer save/deletion. {{{

" For saving current buffer.
map <silent> <F2> :w<CR>

" A buffer with a filetype in this dictionary will have its window closed when
" calling DeleteBuffer.
let g:DeleteBufferFileTypes =
      \ {
      \ 'Decho':1,
      \ 'man':1
      \ }

" Same as above for buffer type.
let g:DeleteBufferBufferTypes =
      \ {
      \ 'help':1,
      \ 'nofile':1,
      \ 'nowrite':1,
      \ 'quickfix':1
      \ }

" Delete the current buffer, issuing bnext in all windows
" where displayed before that.
function! DeleteBuffer()

  let bid = bufnr('%')
  let nbw = winnr('$')
  let dodel = 1

  if &previewwindow
    let dodel = 0
    silent! close
  elseif
\ (!empty(&buftype) && has_key(g:DeleteBufferBufferTypes, &buftype)) ||
\ (!empty(&filetype) && has_key(g:DeleteBufferFileTypes, &filetype))
    if 1 != nbw
      silent! close
    endif
  else
    silent! bprev
  end

  if dodel
    silent! exe 'bdel '.bid
  endif

  if bid == bufnr('%')
    :q
  end

endfunction

" For deleting current buffer (and closing window when needed).
map <silent> <F4> :call DeleteBuffer()<CR>

" }}}

" Trailing spaces/tabs, excess columns highlighting. {{{

set listchars+=tab:__,trail:_

function! ToggleListBlanks()
  if &list
    setlocal nolist
  else
    setlocal list
  endif
endfunction

map <silent> <F5> :call ToggleListBlanks()<CR>

" Function to toggle highlighting the offending parts of lines that are "too
" long", where "too long" is defined by &textwidth or an arg passed to the
" function.

function! ToggleHighlightExcessColumns(width)
  if exists('b:highlight_excess_columns')
    call matchdelete(b:highlight_excess_columns)
    unlet b:highlight_excess_columns
    return
  endif
  let width = a:width != '' ? a:width : &textwidth
  if width > 0
    let b:highlight_excess_columns = matchadd('TODO', '\%>'.(width+1).'v')
  endif
endfunction

map <silent> <C-F5> :call ToggleHighlightExcessColumns('')<CR>

" }}}

" Search highlighting. {{{

function! ToggleSearchHighlighting()
  if &hlsearch
    set nohlsearch
  else
    set hlsearch
  endif
endfunction

map <silent> <F6> :call ToggleSearchHighlighting()<CR>

" }}}

" Launch various commands. {{{

let cmd_1 = "make"
let cmd_2 = "make clean"
let cmd_3 = "make -C %:p:h"
let cmd_4 = "make -C %:p:h clean"

function! Launch_Command(name)
  if exists("b:".a:name)
    execute "let l:cmd=b:".a:name
  elseif exists("g:".a:name)
    execute "let l:cmd=g:".a:name
  else
    return
  endif
  execute "echo \"" . cmd . "\" \| " . cmd
endfunction

noremap <F9>  :call Launch_Command("cmd_1")<CR>
noremap <F10> :call Launch_Command("cmd_2")<CR>
noremap <F11> :call Launch_Command("cmd_3")<CR>
noremap <F12> :call Launch_Command("cmd_4")<CR>

" }}}

" Indent and retab. {{{

function! Indent_and_Retab() range
  if &list
    silent! execute a:firstline.",".a:lastline.'s/\s*\r\?$'
  end
  execute a:firstline.",".a:lastline.'retab'
  execute "normal ".a:firstline."G=".a:lastline . 'G'
endfunction

function! Indent_and_Retab_operator(type)
  :'[,']call Indent_and_Retab()
endfunction

vmap <silent> ,= :call Indent_and_Retab()<CR>
nmap <silent> ,= :set opfunc=Indent_and_Retab_operator<CR>g@
nmap <silent> ,== :.call Indent_and_Retab()<CR>

" }}}

" Swap two pieces of text. {{{

function! SwapText(start, end, visual)

  let b1 = line2byte(line("'.")) + col("'.") - 1
  let b2 = line2byte(line("'".a:start)) + col("'".a:start)

  if b1 > b2
    let s1 = strlen(getreg())
    let s2 = line2byte(line("'".a:end)) + col("'".a:end) - b2 + 1
    let b1 -= s2 - s1
  end

  if a:visual
    exe 'normal gvP'
  else
    exe 'normal `'.a:start.'v`'.a:end.'P'
  endif
  exe 'goto '.b1
  exe 'normal "*P'

endfunction

function! SwapText_operator(type)
  call SwapText('[', ']', 0)
endfunction

function! SwapText_visual() range
  call SwapText('<', '>', 1)
endfunction

function! SwapText_line()
  exe 'normal V,s'
endfunction

vmap <silent> ,s :call SwapText_visual()<CR>
nmap <silent> ,s :set opfunc=SwapText_operator<CR>g@
nmap <silent> ,ss :call SwapText_line()<CR>

" }}}

" Cursor cross.
if has('autocmd')
  autocmd BufWinEnter * set cursorline cursorcolumn
  autocmd WinEnter    * set cursorline cursorcolumn
  autocmd WinLeave    * set nocursorline nocursorcolumn
endif

" Folding. {{{

set foldcolumn=2
set foldlevelstart=99
set foldmethod=syntax

" }}}

" vim: ft=vim sw=2 foldmethod=marker
